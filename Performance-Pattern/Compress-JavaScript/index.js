// 压缩JavaScript并关注bundle的大小可以获得最佳的性能，过高的JavaScript包粒度有助于重复数据删除和缓存，但是在不同的范围内，要选择不同的策略去压缩。

// javascript是页面大小的第二大影响因素，也是图片之后请求量第二大的网络资源。

// 压缩可以帮助减少网络传输脚本所需要的时间。

// 1.HTTP压缩

/**
 * 压缩可以减少文档和文件的大小，它们占用磁盘空间少，消耗带宽低，可以快速传输。
 * HTTP压缩就是通过这个概念来压缩网站内容，减少页面重量，降低带宽要求并提高性能
 */

// HTTP压缩类别：有损压缩和无损压缩
// 有损压缩：压缩-解压循环会导致文档略有改变，但仍然保持其可用性。常见的压缩: 图片JPEG压缩
// 无损压缩：压缩和随后解压后恢复的数据将与原始数据精确匹配。无损压缩与文本传输相关，应用于基于文本的格式，html，css和js

// 2.最小化

/**
 * 为了有效地减少负载大小，可以在压缩之前减少JavaScript。缩小是通过删除空格和任何不必要的代码来创建较小但有效地js文件。
 * 在编写代码时，我们使用换行符、缩进、空格、命名良好的变量和注释来提高代码的可读性和可维护性。但是，这些元素会增加整体 JavaScript 大小，并且对于在浏览器上执行而言并非必需。缩小将 JavaScript 代码减少到成功执行所需的最低限度。
 * 压缩是 JS 和 CSS 优化的标准做法。JavaScript 库开发人员通常会提供其文件的压缩版本以供生产部署，通常以 min.js 扩展名表示。
 */

// 3.静态压缩与动态压缩
// 最小化有助于显著减小文件大小，但 JS 压缩可以带来更显著的好处。您可以通过两种方式实现服务器端压缩。

/**
 * 静态压缩: 您可以使用静态压缩来预压缩资源，并作为构建过程的一部分提前保存它们。在这种情况下，您可以使用更高的压缩级别来缩短代码的下载时间。较长的构建时间不会影响网站性能。最好对不经常更改的文件使用静态压缩。
 * 
 * 动态压缩: 在此过程中，浏览器请求资源时会即时进行压缩。动态压缩更容易实现，但您只能使用较低的压缩级别。较高的压缩级别需要更多时间，并且您将失去较小内容大小带来的优势。如果您对频繁更改或由应用程序生成的内容使用动态压缩，这将有所帮助。
 */

// 4.压缩算法

/**
 * Gzip
 * 基于Deflate算法的无损算法。Deflate算法本身对输入数据流中的数据块结合LZ77算法和Huffman编码
 * LZ77 算法识别重复的字符串，并用反向引用（指向该字符串之前出现位置的指针）替换它们，后面跟着字符串的长度。随后，霍夫曼编码识别常用的引用，并用具有较短位序列的引用替换它们。较长的位序列用于表示不常用的引用。
 * 所有主流浏览器都支持 Gzip。Zopfli压缩算法是 Deflate/Gzip 的一个较慢但经过改进的版本，可生成较小的 GZip 兼容文件。它最适合静态压缩，可提供更显著的增益。
 * 
 * 
 * Brotli
 * Brotli也是一种基于 LZ77 算法和霍夫曼编码的无损算法。此外，它使用二阶上下文建模，以相似的速度实现更密集的压缩。上下文建模是一种功能，允许同一块中同一字母表的多个霍夫曼树。Brotli 还支持更大的反向引用窗口大小，并具有静态字典。这些功能有助于提高其作为压缩算法的效率。
 * 
 * 
 */

// 5.捆绑术语
/**
 * 1.模块: 模块是离散的功能块，旨在提供可靠的抽象和封装。
 * 2.捆绑包: 一组不同的模块，包含源文件的最终版本，且已经在捆绑器中经过加载和编译过程
 * 3.捆绑包拆分: 捆绑器将application拆分为多个chunk包的过程。
 * 4.Chunk: 采用 Webpack 术语，chunk 是打包和代码拆分过程的最终输出。Webpack 可以根据入口配置、SplitChunksPlugin或动态导入将包拆分为块。
 * 
 * JavaScript 的输出大小是指经过 JavaScript 打包器或编译器优化后的块大小或原始大小。大型 JS 应用程序可以分解为可独立加载的 JavaScript 文件块。加载粒度是指输出块的数量 - 块数越多，每个块的大小越小，粒度越高。
 * 
 * 页面所需的每个块字节都需要由用户设备下载和解析/执行。这是直接影响应用程序性能的代码。由于块是最终要下载的代码，因此压缩块可以提高下载速度。
 */