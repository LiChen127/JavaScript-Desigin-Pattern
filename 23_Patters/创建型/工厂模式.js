/**
 * 工厂模式定义一个用于创造对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到子类。
 * 而子类可以重写接口方法以便创建的时候指定自己的对象类型
 */

class Product {
  constructor(name) {
    this.name = name;
  }
  init() {
    console.log('init');
  }
  fun() {
    console.log('fun');
  }
}

class Factory {
  create(name) {
    return new Product(name);
  }
}

/**
 * 适用场景:
 * 1.如果不想让某个子系统与较大的那个对象之间形成强耦合，而是从耦合中解放出来，就可以使用工厂模式。
 * 2.需要依赖具体环境创建不同的实例，这些实例由相同行为，这时候可以使用工厂模式来创建。
 */

/**
 * 优点:
 * 不需要考虑如何创建对象，只需要考虑结果;
 * 构造函数和创建者分离;
 * 可扩展性高，如果想要增加一个产品，只要拓展一个工厂类即可
 */

/**
 * 缺点:
 * 添加新产品时，需要编写新的具体产品类;
 * 考虑到系统的可拓展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义;
 */

/**
 * 例子:
 * 1.Jquery
 * 2.Vue的异步组件
 * Vue允许以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义.Vue只有在这个组件需要被渲染的时候才会触发工厂函数，且会把结果缓存起来供未来重新渲染
 */